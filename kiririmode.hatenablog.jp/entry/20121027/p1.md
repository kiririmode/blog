---
Title: screen の STRING ESCAPES
Category:
- environment
Date: 2012-10-27T00:00:00+09:00
URL: https://kiririmode.hatenablog.jp/entry/20121027/p1
EditURL: https://blog.hatena.ne.jp/kiririmode/kiririmode.hatenablog.jp/atom/entry/8454420450078210103
---


screen の caption については、凝れば凝るほど黒魔術的な様相を呈してしまうので、このあたりでまとめておきたい。

**文字列置換
まずは基本として、単純な文字列置換についてまとめておく。
***%a
現在時刻に合わせて am か pm かが表示される
***%A
%a と同じだけど、AM、PM というように大文字になる
***%c, %C
現在時刻に合わせて、現在時刻が HH:MM フォーマットで表示する。%c が 24 時間表記、%C は 12 時間表記。
ちなみに、たとえば 01:00 の場合、%c にすると「 1:00」となるが、%0c というように 0 を挟むと「01:00」というように空白でなく 0 でパディングされるようになる。
***%C
現在時刻に合わせて、現在時刻が HH:MM フォーマット(12 h 表記)で表示される。
***%d
現在日の表示。
***%D
曜日の表示。%D そのままだと、Sun、Mon といった略称表記になる(ちなみに、この例は LANG=C の場合)。
また、%LD というように 'L' を挟むと Saturday というようなフル表記となる。
***%f
ウィンドウの状態を表すフラグが確認できる。
%f についてはぼく自身は網羅的な理解はしていないので、具体例だけ示したい。

通常、screen では新規ウィンドウで起動するプログラムを指定できる(多くの場合はシェルを指定しているはず)のだけれど、このプログラムのプロセスが消えるとウィンドウごと消える。
ただし、zombie で設定を仕込むと、ユーザが特定キーを押すまで、「プロセスは死んだけれどウィンドウは残っている」という状態を作りだせる。このウィンドウの状態は zombie として定義されていて、この場合は %f が zombie 状態を表す「Z」に置換される。
***%h
一般に hardstatus は screen の機能ではなくて、TTY の機能。起動しているコマンドによっては、この TTY の hardstatus に何かを出力するケースがあり、%h はそれを出力させる機能。
screen 使っている人は、hardstatus を単なる「便利な出力領域」として使っているケースが多く、ほとんどの場合コマンドが出力する hardstatus は握りつぶしているので、指定するケースあんましないと思う。
***%H
screen 起動させているホスト名。
***%l
ロードアベレージの表示。ときどきロードアベレージを backtick 使って表示させている人がいるけど、%l でも良いのではとか思う。
***%m
現在の月の表示。
***%M
現在の月名の表示。今だと Oct になる。
%LM というように 'L' を挟むと、October というようにフル表記になる。
***%n
window 識別用の番号(window number)を表示する。screen が自動で採番する。
ちなみに、%n は %3n などの桁指定を認識してくれる。ただし、%03n 等の 0 パディングまでは対応していないみたい。
***%s
現在秒の表示。
***%t
window に与えたタイトルの表示。
***%w
window number とタイトルを一覧で表示してくれる。%-w とした場合は、現在選択中の window より前の window のみが一覧表示され、%+w とした場合は、選択中の window より後の window が一覧表示される。
で、さらに %Lw というように 'L' を挟むと、window flag も合わせて表示するモードに変化する。
***%W
現在選択中の window を除く window number・タイトルを一覧表示する
***%y, %Y
現在年の西暦表示。%y は下 2 桁。%Y は 4 桁表示。

**分岐条件
この分岐条件を持たせることで、screen の caption や hardstatus の柔軟性というのは一気に向上し、同時に黒魔術っぽさも異常に向上することになる。
>|tcsh|
%? [partA] %: [partB] %?
||<
で一組。
partA は何らかのエスケープ文字列で、この partA が空文字列にならなければその文字列が表示されるし、partA が空文字列として展開されるようなら、partB の文字列が表示されることになる。
疑似言語で書けば
>|perl|
if not empty [partA]
    print [partA]
else
    print [partB]
||<
といった趣き。


ただし例外は、%F と組み合わせるとき。%F は、ウィンドウをユーザが選択中であるときにのみ真になるのだけれど、これを分岐条件に使うときは
>|tcsh|
%?%F [partA] %: [partB] %?
||<
という形で使う。このときのみ、[partA] は分岐条件でなくなる。
>|perl|
if this window is selected
    print [partA]
else
    print [partB]
||<


**コマンド置換
これを説明するには backtick 機能から説明する必要がでてきて面倒なんだけど、screen には任意のコマンドの結果を表示できる機能がある。
>|tcsh|
backtick id lifespan autorefresh cmd args...
||<
というフォーマットで .screenrc に書いておけば、lifespan/autorefresh 秒毎に、任意の cmd args ... が実行されて、その標準出力が記憶される。caption やら hardstatus やらで $` と指定してやれば、その標準出力の最終行で置換されることになる。
たとえば、caption に Livedoor Reader の未読数を 5 分更新で表示させたい場合は、以下で実現できる。
>|tcsh|
caption always "%`"
backtick 0 300 300 sh -c 'num=`curl http://rpc.reader.livedoor.com/notify?user=username 2> /dev/null | cut -d\| -f2`; printf "%4d" $num'
||<

ちなみに、この backtick というのは複数個の指定が可能で、それは id で識別可能。
たとえば $0`、$1` という指定で、id 0 の backtick、id 1 の backtick それぞれの標準出力で置換できることになる。

**位置制御
***%=
どの位置(桁)から文字を出力させるかというポインタを記載できる。
%10= で左から 10% の位置、というように割合を指定できるのだけれど、%010= のように '0' を加えることで、「左から 10 文字目」というような絶対位置を指定することも可能。

***%>
ターミナルのサイズが出力したい文字列長よりも短い場合に、いいかんじに truncate してくれる。
実際には %50> とかで指定すると、その指定の次の文字が左から 50% の位置になるように「いいかんじに」truncate してくれる。さらに、%50L> というように 'L' を付けると、truncate された部分に ... というような三点リーダを付けてくれる。
