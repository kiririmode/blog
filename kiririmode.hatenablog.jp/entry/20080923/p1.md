---
Title: JIT コンパイルを理解する
Category:
- java
Date: 2008-09-23T00:00:00+09:00
URL: https://kiririmode.hatenablog.jp/entry/20080923/p1
EditURL: https://blog.hatena.ne.jp/kiririmode/kiririmode.hatenablog.jp/atom/entry/8454420450078214119
---

前からちょっと気になっていたんですけど，イマイチ理解不足でしたから，この際にちょっといろんなところを眺めてみようと思いたったのです．以下がその眺めた結果として得たものなんですけど，こんなのは wikipedia とかを数十分眺めただけですから，往々にして間違いとかが入ってしまう．しかし，例え間違っていようとも，勉強結果をアウトプットするのは超重要，アウトプットするときになって初めて自分の頭の中が整理されるのです!!

**JIT コンパイルの概要

JIT は Just in Time の略なわけですが，その名前のとおり，実行時になってコンパイルをするという技術です．e-Words 的には Java 限定なんだけど，現在では Java だけでなくいろんな言語で既に採用されてたりしますね．
>http://e-words.jp/w/JITE382B3E383B3E38391E382A4E383A9.html:title>
　Javaプログラムを実行する際に、プラットフォームから独立した形式のプログラム(Javaバイトコード)を、実行前にまとめて一気にそのプラットフォームで実行可能なプログラム(ネイティブコード)に変換し、実行する機構のこと。
<<

インタプリタ形式だと逐一の命令に対して解釈の時間がかかってクソみたいに遅い．JIT コンパイルはコードの塊を実行時にコンパイルすることで，インタプリタに比べてチョー早くなる．まぁ同じコード片を繰り返し実行するときとか考えると，インタプリタは同じ処理なのに毎回解釈してアホみたいだ．一旦コンパイルしとくと，解釈の時間とか必要なくて，コードを実行するだけで済みますから，直感的にそのメリットが理解できます．もちろんコンパイル時間はオーバヘッドにはなります．

**Static Compile との比較

もちろん予めバイナリレベルにまでコンパイルしてガンガン最適化しておく方式に比べると，基本的には性能が良くない．ただ，JIT コンパイルは一般的にバイトコードからバイナリに変換するときに使われる．メンドい処理とかはソース->バイトコード変換時に行われるので，そういうときは Static Compile との差がちょっと縮まったりします．バイトコード->バイナリのコンパイルは，ソース->バイトコード変換に比べると軽い処理ってことですね．
また，[http://en.wikipedia.org/wiki/Just-in-time_compilation:title] を見ると，Static Compile に対するメリットとして以下のものが説明されています．
-ターゲット CPU に対する実行時の最適化が可能
実行される CPU の情報が取得できる状況でのコンパイルが可能なので，SSE とかを使ったりできるってわけです．
-コンパイル後，実際にどう動いたかって情報も得ることができるので，必要とあらば再コンパイルをかけることによってパフォーマンスを向上させることができる
-メモリ(配置を？)再構成してキャッシュの利用状況を改善させることができる
ちなみにこのセンテンスが言いたいことはよくわからなかった．
>>
The system can do global code optimizations (e.g. in-lining of library functions) without losing the advantages of dynamic linking and without the overheads inherent to static compilers and linkers.
<<
