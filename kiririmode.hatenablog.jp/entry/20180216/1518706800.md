---
Title: 困ったときのパケットキャプチャ+curl
Category:
- unix
Date: 2018-02-16T00:00:00+09:00
URL: https://kiririmode.hatenablog.jp/entry/20180216/1518706800
EditURL: https://blog.hatena.ne.jp/kiririmode/kiririmode.hatenablog.jp/atom/entry/17391345971617504351
---

リバースプロキシから渡ってきた HTTP リクエストで WebApp がエラーになるという状況が発生しました。
状況としては、

* リバプロにはぼくたちはアクセスできないし、そのリバプロにリクエストを送ることもできない。
* リバプロから WebApp 用 FW に何らかの HTTP ヘッダを連携することになっているが、果たして送られているのかが不明

という状況。正確に何が起こっているのか分からない状況で鍵になるのは事象の再現であり、このときに採った戦略はパケットキャプチャでリクエスト内容を確認し、それを `curl` で再現することでした。

容易にサーバ上にツールを導入できる状況でもなかったので、tcpdump が使えたことは本当に有り難かったです。また、自分の端末にもソフトウェアを簡単に導入できない環境ではあったものの、[https://www.wireshark.org/:title=WireShark:bookmark] が入っていたのも良かった。
この 2 つが揃っていれば、あとやることは多くない。

# tcpdump

WireShark が使えてトラフィック量も多くないことは分かっていたので、フィルタすることなく、全パケットを取得するようにした。フィルタ自体は WireShark でやれば良いだろという雑な考え方。
tcpdump でプロミスキャスモードにするときは、一般にはログが自動的に記録されてしまうので、これってポリシ的にだいじょうぶ？？という点は気を配った。

ぼくが tcpdump を使うときは、`-s0` は必ず指定するようにしていて、昔これを付けていなかったばっかりに、各パケットの切り詰められた結果しかキャプチャできていなかった辛い思いをもうしたくないからです。

```tcsh
# tcpdump -i <interface> -n -s0 -w /tmp/capture-$(date +%Y%m%d-%H%M%S).pcap
```

あとは、ここで取得した pcap ファイルを WireShark にかければ良い。


# リクエストの再現

WireShark で適切なフィルタをかけることで、エラーを発生させたリクエストは確認できるので、あとはそのリクエストを `curl` あたりで再生すれば再現できる。

まがりなりにもストートレスかつテキストなプロトコルである HTTP だとこのあたりが楽で良いなと思います。HTTP 2.0 だとどうなるんでしょう。
