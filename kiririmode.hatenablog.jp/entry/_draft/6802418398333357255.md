---
Title: syftとgrypeでJavaとNode.jsプロジェクトの依存関係と脆弱性を可視化する
Category:
- Security
- Development
- Java
- Node.js
- SBOM
Date: 2025-03-03T03:52:01Z
URL: https://kiririmode.hatenablog.jp/entry/20250303/1709436721
EditURL: https://blog.hatena.ne.jp/kiririmode/kiririmode.hatenablog.jp/atom/entry/6802418398333357255
---

最近、オープンソースソフトウェアを利用したサプライチェーン攻撃が増加しており、プロジェクトの依存関係管理と脆弱性対策の重要性が高まっています。僕自身、開発プロジェクトで数多くの依存パッケージを利用していますが、それらの依存関係を可視化し、潜在的な脆弱性を検知する必要性を感じていました。

今回は、syftとgrypeという2つのツールを使って、JavaプロジェクトのPOM（pom.xml）とNode.jsプロジェクトのpackage.jsonから依存関係を可視化し、脆弱性を検知する方法を紹介します。

[:contents]

# syftとgrypeとは

## syft：依存関係の可視化ツール

syftは、Anchore社が開発したソフトウェアコンポーネントの依存関係を分析し、SBOMを生成するツールです。SBOMとは「Software Bill of Materials」の略で、ソフトウェアの構成要素を一覧化したものとなります。

以下のような特徴があります。

- 多様なパッケージマネージャーのサポート（Maven、npm、etc）
- 複数のフォーマット（JSON、SPDX、CycloneDX）でのSBOM生成
- コンテナイメージの解析にも対応
- 実行が高速

## grype：脆弱性スキャンツール

grypeもAnchore社が開発した脆弱性スキャンツールで、syftと連携して動作します。主な特徴は以下の通りです。

- 最新の脆弱性データベースを活用
- 重要度に基づく脆弱性の分類
- 豊富な出力フォーマット
- 高速な脆弱性スキャン

# ローカルでの環境構築

## インストール

まず、syftとgrypeをローカルPCにインストールします。

```bash
# syftのインストール
curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

# grypeのインストール
curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
```

インストールが完了したら、バージョンを確認します。

```bash
$ syft version
Application: syft
Version:    1.20.0
BuildDate:  2025-02-21T20:31:16Z
GitCommit:  Homebrew
GitDescription: [not provided]
Platform:   darwin/arm64
GoVersion:  go1.24.0
Compiler:   gc

$ grype version
Application:         grype
Version:             0.87.0
BuildDate:           2025-01-22T20:31:08Z
GitCommit:           Homebrew
GitDescription:      [not provided]
Platform:            darwin/arm64
GoVersion:           go1.23.5
Compiler:            gc
Syft Version:        v1.19.0
Supported DB Schema: 5
```

# Javaプロジェクト（pom.xml）の解析

## 実際のプロジェクトでの依存関係の可視化

まず、手元のJavaプロジェクトの依存関係を解析してみましょう。以下は、[nablarch-core](https://github.com/nablarch/nablarch-core)プロジェクトを例にしています。

```bash
cd /Users/kiririmode/src/github.com/nablarch/nablarch-core
syft pom.xml
```

このコマンドを実行すると、以下のような形式でプロジェクトの依存関係が表示されます。

```text
 ✔ Indexed file system    pom.xml
 ✔ Cataloged contents     edd2b8dd54f1c8190d6e78966c59d78d0380cc917d896769b347f2067e547caa
   ├── ✔ Packages                        [4 packages]
   ├── ✔ File digests                    [1 files]
   ├── ✔ File metadata                   [1 locations]
   └── ✔ Executables                     [0 executables]
NAME                    VERSION  TYPE
json-path-assert        2.4.0    java-archive
mockito-core            UNKNOWN  java-archive
nablarch-core           2.2.0    java-archive
nablarch-slf4j-adaptor  UNKNOWN  java-archive
```

より詳細な情報をSBOMで出力することもできます。例えば、SPDX形式で出力し、ソフトウェアコンポーネント（`packages`）の一部情報を出力してみましょう。

```bash
$ syft -q pom.xml -o spdx-json | jq -r '.packages[] | [ .name, .SPDXID, .versionInfo ] | @csv '
syft -q pom.xml -o spdx-json | jq -r '.packages[] | [ .name, .SPDXID, .versionInfo ] | @csv '
"json-path-assert","SPDXRef-Package-java-archive-json-path-assert-b9f8b5dad3d5ab1d","2.4.0"
"mockito-core","SPDXRef-Package-java-archive-mockito-core-b1a15a6e93dab83d","UNKNOWN"
"nablarch-core","SPDXRef-Package-java-archive-nablarch-core-20c66a65499e2f90","2.2.0"
"nablarch-slf4j-adaptor","SPDXRef-Package-java-archive-nablarch-slf4j-adaptor-f3cc12b003c1b302","UNKNOWN"
"pom.xml","SPDXRef-DocumentRoot-File-pom.xml","sha256:3b110735d9a8c1b259d3b123e286e4ce48c876012e6e4d2fd8c9020a65c84e12"
```

きちんと抽出されているようです。

### 親POMからの依存関係の解決

一方で、mockito-core のバージョンが `UNKNOWN` となっているのは、syftが親POMを見てくれていないためのようです。こちらがnablarch-coreの生pom.xmlですが、確かにバージョン指定は存在していません。

```xml
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <scope>test</scope>
    </dependency>
```

他方、`mvn dependency:tree` の結果を見ると当然mockito-coreのバージョンが表示されています。

```tcsh
mvn dependency:tree | sed -n '/dependency/,/----/p'
[INFO] --- dependency:3.7.0:tree (default-cli) @ nablarch-core ---
[INFO] com.nablarch.framework:nablarch-core:jar:2.2.0
[INFO] +- org.mockito:mockito-core:jar:5.3.0:test
[INFO] |  +- net.bytebuddy:byte-buddy:jar:1.14.4:test
[INFO] |  +- net.bytebuddy:byte-buddy-agent:jar:1.14.4:test
[INFO] |  \- org.objenesis:objenesis:jar:3.3:test
[INFO] +- com.jayway.jsonpath:json-path-assert:jar:2.4.0:test
[INFO] |  +- com.jayway.jsonpath:json-path:jar:2.4.0:test
[INFO] |  |  \- net.minidev:json-smart:jar:2.3:test
[INFO] |  |     \- net.minidev:accessors-smart:jar:1.2:test
[INFO] |  |        \- org.ow2.asm:asm:jar:5.0.4:test
[INFO] |  +- org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] |  +- org.hamcrest:hamcrest-library:jar:1.3:test
[INFO] |  \- org.slf4j:slf4j-api:jar:1.7.25:test
[INFO] +- com.nablarch.integration:nablarch-slf4j-adaptor:jar:2.1.0:test
[INFO] +- junit:junit:jar:4.13.1:test
[INFO] +- org.hamcrest:hamcrest-all:jar:1.3:test
[INFO] \- org.jacoco:org.jacoco.agent:jar:runtime:0.8.8:test
[INFO] ------------------------------------------------------------------------
```

これ、一応Maven Cacheがローカルにある前提で言えば環境変数として`SYFT_JAVA_USE_MAVEN_LOCAL_REPOSITORY=true`を設定すれば解決するし、あるいはネットワーク疎通性がある前提で言えば `SYFT_JAVA_USE_NETWORK=true`を設定することで解決できます。これドキュメントされてないんだけど、Issueにはあるので、知っている人は知っている。

`SYFT_JAVA_USE_MAVEN_LOCAL_REPOSITORY`はローカルのMaven Cacheを見て判断してくれるオプション。

[https://github.com/anchore/syft/issues/3207:embed]

```diff
$ diff -u <(syft -q pom.xml) <(SYFT_JAVA_USE_MAVEN_LOCAL_REPOSITORY=true syft -q pom.xml)
--- /dev/fd/11 2025-03-03 14:18:08
+++ /dev/fd/12 2025-03-03 14:18:08
@@ -1,5 +1,5 @@
 NAME                    VERSION  TYPE
 json-path-assert        2.4.0    java-archive
-mockito-core            UNKNOWN  java-archive
+mockito-core            5.3.0    java-archive
 nablarch-core           2.2.0    java-archive
-nablarch-slf4j-adaptor  UNKNOWN  java-archive
+nablarch-slf4j-adaptor  2.1.0    java-archive
```

一方で`SYFT_JAVA_USE_NETWORK`はネットワークを使って必要なPOMを取得してくれるオプション。

[https://github.com/anchore/syft/pull/2769#issuecomment-2248935740:embed]

```diff
$ diff -u <(syft -q pom.xml) <(SYFT_JAVA_USE_NETWORK=true syft -q pom.xml)
--- /dev/fd/11 2025-03-03 14:25:27
+++ /dev/fd/12 2025-03-03 14:25:28
@@ -1,5 +1,5 @@
 NAME                    VERSION  TYPE
 json-path-assert        2.4.0    java-archive
-mockito-core            UNKNOWN  java-archive
+mockito-core            5.3.0    java-archive
 nablarch-core           2.2.0    java-archive
-nablarch-slf4j-adaptor  UNKNOWN  java-archive
+nablarch-slf4j-adaptor  2.1.0    java-archive
```

## 脆弱性の検知

続いて、grypeを使って脆弱性をスキャンします。

```bash
$ SYFT_JAVA_USE_NETWORK=true syft -q pom.xml -o cyclonedx-json=nablarch-core.cyclonedx.json
$ grype -q nablarch-core.cyclonedx.json
No vulnerabilities found
```

nablarch-coreには脆弱性は存在していないようですね。

# Node.jsプロジェクト（package.json）の解析

## 依存関係の可視化

Node.jsプロジェクトも同様に解析できます。ここではPromptisを解析してみましょう。

```bash
$ cd /Users/kiririmode/src/github.com/Fintan-contents/promptis
$ syft -q package.json
No packages discovered
```

何と、パッケージが検出されません。
ここで、`--select-catalogers`オプションを使って、JavaScriptパッケージカタログを明示的に指定するときちんと解析がなされます。

```bash

```tcsh
$ syft -q package-lock.json --select-catalogers '+javascript-package-cataloger' | head
NAME                             VERSION  TYPE
@tootallnate/quickjs-emscripten  0.23.0   npm
agent-base                       7.1.1    npm
ast-types                        0.13.4   npm
balanced-match                   1.0.2    npm
basic-ftp                        5.0.5    npm
brace-expansion                  2.0.1    npm
data-uri-to-buffer               6.0.2    npm
debug                            4.3.7    npm
degenerator                      5.0.1    npm
```

## catalogersとは何か

実はSyftは、依存関係の解析において、どのカタログを使うかを自動的に判断します。カタログとは、特定の言語やパッケージマネージャーに対応した依存関係の解析を行うためのプラグインです。Syftは、プロジェクトのファイル構造やファイル名、ファイルの内容などを元に、適切なカタログを選択します。

単に`package.json`を与えるだけではこのカタログの選択がうまくいかない場合があるので、`--select-catalogers`オプションを使って、明示的にカタログを指定することができます。どういうカタログがあるのかは `syft cataloger list` で確認できます。

```tcsh
$ syft cataloger list -o json | jq -r '.catalogers[].name'
alpm-db-cataloger
apk-db-cataloger
binary-classifier-cataloger
bitnami-cataloger
cargo-auditable-binary-cataloger
cocoapods-cataloger
conan-cataloger
conan-info-cataloger
dart-pubspec-lock-cataloger
dotnet-deps-cataloger
dotnet-packages-lock-cataloger
dotnet-portable-executable-cataloger
dpkg-db-cataloger
elf-binary-package-cataloger
elixir-mix-lock-cataloger
erlang-otp-application-cataloger
erlang-rebar-lock-cataloger
file-content-cataloger
file-digest-cataloger
file-executable-cataloger
file-metadata-cataloger
github-action-workflow-usage-cataloger
github-actions-usage-cataloger
go-module-binary-cataloger
go-module-file-cataloger
graalvm-native-image-cataloger
haskell-cataloger
java-archive-cataloger
java-gradle-lockfile-cataloger
java-jvm-cataloger
java-pom-cataloger
javascript-lock-cataloger
javascript-package-cataloger
linux-kernel-cataloger
lua-rock-cataloger
nix-store-cataloger
opam-cataloger
php-composer-installed-cataloger
php-composer-lock-cataloger
php-pecl-serialized-cataloger
portage-cataloger
python-installed-package-cataloger
python-package-cataloger
r-package-cataloger
rpm-archive-cataloger
rpm-db-cataloger
ruby-gemfile-cataloger
ruby-gemspec-cataloger
ruby-installed-gemspec-cataloger
rust-cargo-lock-cataloger
sbom-cataloger
swift-package-manager-cataloger
swipl-pack-cataloger
terraform-lock-cataloger
wordpress-plugins-cataloger
```

## 脆弱性の検知

package.jsonに記載された依存パッケージの脆弱性をスキャンします。

```bash
$ syft -q package-lock.json --select-catalogers '+javascript-package-cataloger' -o cyclonedx-json=promptis.cyclonedx.json
grype -q promptis.cyclonedx.json
No vulnerabilities found
```

脆弱性ないんかい〜。良かったような悪かったような。

### ローカルの脆弱性

脆弱性がないのも困るので、このBlogを記述しているディレクトリ配下にある脆弱性をサクッと調べてみます。syftでSBOMを生成し、それをパイプ経由でgrypeに渡してスキャンしてみましょう。

```tcsh
$ syft . -qo cyclonedx-json | grype -q
NAME      INSTALLED  FIXED-IN  TYPE    VULNERABILITY        SEVERITY
black     23.12.1    24.3.0    python  GHSA-fj7x-q9j7-g6q6  Medium
jinja2    3.1.2      3.1.5     python  GHSA-q2x7-8rv6-6q7h  Medium
jinja2    3.1.2      3.1.4     python  GHSA-h75v-3vvj-5mfj  Medium
jinja2    3.1.2      3.1.3     python  GHSA-h5c8-rqwp-cp95  Medium
jinja2    3.1.2      3.1.5     python  GHSA-gmj6-6f8f-6699  Medium
werkzeug  3.0.1      3.0.3     python  GHSA-2g68-c3qc-8985  High
werkzeug  3.0.1      3.0.6     python  GHSA-q34m-jh98-gwm2  Medium
werkzeug  3.0.1      3.0.6     python  GHSA-f9vj-2wh5-fj8j  Medium
```

おお、色々出てきました。
特定の重要度以上の脆弱性が存在したら、コマンドを失敗させることもできます。

```bash
$ syft . -qo cyclonedx-json | grype -q --fail-on high > /dev/null
$ echo $?
1
```

# まとめ

syftとgrypeを活用することで、以下のメリットが得られます：

- プロジェクトの依存関係の可視化が容易に
- 潜在的な脆弱性を素早く発見可能
- 脆弱性の重要度に基づく対応の優先順位付けが可能
- 定期的なセキュリティチェックの自動化

JavaとNode.jsのプロジェクトでは、数多くの依存パッケージを使用することが一般的なため、これらのツールによる継続的な監視が重要です。今回紹介した方法を活用して、プロジェクトのセキュリティ管理を効率的に行っていきましょう。
