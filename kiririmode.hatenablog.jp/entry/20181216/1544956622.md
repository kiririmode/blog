---
Title: bitcoinにおける署名アルゴリズム (ECDSA)
Category:
- bitcoin
- protocol
Date: 2018-12-16T19:37:02+09:00
URL: https://kiririmode.hatenablog.jp/entry/20181216/1544956622
EditURL: https://blog.hatena.ne.jp/kiririmode/kiririmode.hatenablog.jp/atom/entry/10257846132685729389
---

bitcoin において使われているのは楕円曲線暗号で、この楕円曲線暗号を使った署名(ECDSA)が bitcoin の一つの柱になっています。
ようやくですがこのあたりの署名について少しずつ少しずつ理解が進んできたので、忘れる前にその理解を書き残しておこうと思います。

[:contents]

# 楕円曲線の基本

暗号界隈における楕円曲線というのは、素数 [tex:p] を法として [tex:y^{2} = x^{3} + ax + b] という式で表されます。
[tex:a, b, p] は曲線のパラメータであって、このパラメータに応じて無数の曲線が定義されることになります。

## 楕円曲線上の和

楕円曲線上の点の集合には加算(和)が定義できます。

[tex:P\_{A} (x\_{A}, y\_{A})] と [tex:P\_{B}(x\_{B},y\_{B})] の和 [tex:P\_{A}+P\_{B}] は、2 点 [tex:P\_{A}] と [tex:P\_{B}] を通る直線と楕円曲線との交点 [tex:Q] に関し、[tex:y] 座標の符号を逆にした点として定義されます。

これ、図なしで説明すると何がなにやら分からないと思うんですが、以下のエントリの「楕円曲線上の加算」なんかが分かりやすいかと思います。

[https://johnta.hatenablog.com/entry/2017/12/15/110803:embed]


これら楕円曲線上の点の集合と上記で定義される「和」について、特定の点 [tex:G] に着目し [tex:2G, 3G, 4G, \cdots] と計算していくと、最終的には無限遠点 [tex:O] に辿りつきます。

ここで、[tex:\langle G \rangle=\{G, 2G, 3G, \cdots, O\}] と定義すると、[tex:\langle G \rangle] は、いわゆる[wikipedia:有限アーベル群]を構成します。このとき、単位元は無限遠点 [tex:O] になります。
ここでいう [tex:G] が、生成元、あるいはベースポイントといわれるヤツですね。(ref: [wikipedia:群の生成系])

# bitcoin で使われる楕円曲線

楕円曲線は無数にありますが、bitcoin で使われる曲線は secp256k1 として明確な定義があります。

secp256k1 では、素数 [tex:p] は [tex:p=2^{256}-2^{32}-977] として定義されます。
また、曲線は [tex:a=0, b=7] というパラメータを持ちます。つまりは [tex:y^{2}=x^{3}+y] という式で定義される曲線が、bitcoin で使われる楕円曲線です。


楕円曲線には当然のように [tex:G] を生成元とする有限アーベル群が構成できますが、この生成元 [tex:G] として何を使うかも secp256k1 は規定していて、その点は

- [tex:x]座標: `0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798`
- [tex:y]座標: `0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8`

(※16進数表記) になります。

# ECDSA: Elliptic Curve Digital Signature Algorithm

Bitcoin における公開鍵暗号は、楕円曲線上の生成元 [tex:G] と [tex:e] に対し、[tex:P=eG] は簡単に計算できるけれど、[tex:e=P/G] は容易に計算できないという [wikipedia:離散対数] 問題を基礎にしています。
ここで、[tex:P] が楕円暗号における公開鍵、[tex:e] が秘密鍵に該当します。

bitcoin における電子署名は以下のように計算されます。

## 前提

1. 秘密鍵 [tex:e] に対し、点 P を [tex:eG] として定義する。つまり、[tex:P=eG]
2. 署名する側はランダムな値 [tex:k] を取得し、点 [tex:R=kG] とする。この点 [tex:R] の [tex:x] 座標を [tex:r] とする。

## 署名計算

まず認めなければならないのは、[tex:uG+vP=R] なる [tex:u \ne 0, v \ne 0] を見つける問題は離散対数問題であるということです。なぜか。

まず、この式を変形すると、[tex:P=\frac{k-u}{v}G=eG] つまり [tex:e=\frac{k-u}{v}] になります。
つまり、[tex:uG+vP=R] なる[tex:u \ne 0, v \ne 0] が簡単に求められるということは、容易に離散対数問題が解けるということになってしまいます。

逆に言うと、秘密鍵 [tex:e] を知っている者 (署名者) でなければ、[tex:uG+vP=R] を成立させるような [tex:u \ne 0, v \ne 0] は分からない、ということです。


ここまでの議論で、[tex:uG+vP=R] なる[tex:u \ne 0, v \ne 0] を求められることを示せれば、秘密鍵を持っているということを示せそうです。
ただ、ここで我々は電子署名の議論をしているのですから、秘密鍵を持っているということだけでなく、「正しいメッセージ」を送っている、ということを示したい。

そのため、メッセージ全体のハッシュ値を [tex:z]、新しい変数 [tex:s] を導入し、[tex:u=\frac{z}{s}, v=\frac{r}{s}] と置いてみましょう。実は、ここで導入されるハッシュ値 [tex:z] と [tex:r, s] があれば、受信側で署名の検証を行うことができます。

まず、先程から何度も記載している式[tex:uG+vP=R=kG] に [tex:P=eG] を代入してみましょう。結果、[tex:uG+veG=kG] です。
ここで両辺から [tex:G] を除けば、[tex:u+ve=k=\frac{z}{s}+\frac{re}{s}] が成立します。
これを [tex:s] について解くと、[tex:s=\frac{z+re}{k}] になります。

署名者はこのようにして求められる [tex:s] と点 [tex:R] の [tex:x] 座標 [tex:r] を受信側に送ることになります。

## 署名検証

上記によって計算される [tex:r, s] があれば、受信側に秘密鍵 [tex:e] を送信することなく、署名を検証することが可能です。

前提として、[tex:r] は [tex:R=kG] によって計算される点 [tex:R] の [tex:x] 座標、また、[tex:s=\frac{z+re}{k}] です。


さきほどの議論から、[tex:uG+vP=\frac{z}{s}G+\frac{r}{s}P] です。受信側は以下の理由から、ここで表現されるすべての値を知っています。

- [tex:z]: メッセージのハッシュ値なので計算可能
- [tex:s]: 受信する値
- [tex:G]: secp256k1 で定義されている値
- [tex:r]: 受信する値
- [tex:P]: 署名側の公開鍵なので既知として扱える

この式をそのまま変形していくと、[tex:uG+vP=\frac{z}{s}G+\frac{r}{s}eG=\frac{z+re}{s}G] です。
ここで、[tex:s] を代入すると、[tex:uG+vP=(z+re)\frac{k}{z+re}G=kG=R] となり、[tex:R] が導出できます。

送信してきた側、つまり署名者がこのような [tex:u, v] を見つけられたということは、即ち署名者が正しい秘密鍵 [tex:e] を持っていたことに他なりません。

# まとめ

というわけで、bitcoin における電子署名とその検証について記載してみました。よく考えられているなぁと思うことしきりです。
